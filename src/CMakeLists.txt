project(qucsator_app CXX C)
cmake_minimum_required(VERSION 3.16)

include(${PROJECT_SOURCE_DIR}/../../cmake/readMakeList.txt)

# qucsator_SOURCE_DIR is set when the project qucsator exists.
# If this project is build by it self, this variable is not set
if (NOT qucsator_SOURCE_DIR)
        set(qucsator_SOURCE_DIR ${PROJECT_SOURCE_DIR}/..)
	set(qucsator_BINARY_DIR ${qucsator_app_BINARY_DIR})
endif()

OPTION(ENABLE_CHECKS "enable checks of functions, default: OFF" OFF)

#TODO: do that only if they are not set previously
# Define to the address where bug reports for this package should be sent.
set(PACKAGE_BUGREPORT "qucs-bugs@lists.sourceforge.net")

# Define to the full name of this package.
set(PACKAGE_NAME "qucsator")

# Define to the full name and version of this package.
set(PACKAGE_STRING "${PACKAGE_NAME} ${PROJECT_VERSION}")

# Define to the one symbol short name of this package.
set(PACKAGE_TARNAME ${PACKAGE_NAME})

# Define to the home page for this package.
set(PACKAGE_URL "http://sourceforge.net/projects/qucs/")

#Check dependencies: bison, flex, sed, gperf ...
include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/dependencies.cmake)
if (ADMSXML) # set in dependencies.cmake
	set(USE_VERILOG true)
else()
	set(USE_VERILOG false)
endif()

# Check for type sizes
include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/checkTypeSize.cmake)
##
# Configure the header qucs_typedefs.h, interpolate definitions in checkTypeSize
#
configure_file("${qucsator_SOURCE_DIR}/qucs_typedefs.h.cmake"
        "${qucsator_BINARY_DIR}/qucs_typedefs.h")

if (ENABLE_CHECKS)
	# Do some checks
	include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/checks.cmake)
endif()

#
# Configure the header config.h, interpolate above definitions.
#
configure_file("${qucsator_SOURCE_DIR}/config.h.cmake"
        "${qucsator_BINARY_DIR}/config.h")

include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/generateLexerParserFiles.cmake)

#
# Source code libqucs
#
#    equation.cpp # <= depends on gperfapphash.cpp
#list(LENGTH ${generated_SRC} NUMBER_ELEMENTS)
#message("NUMBER_ELEMENTS: ${NUMBER_ELEMENTS}")
#if (${NUMBER_ELEMENTS} LESS_EQUAL "0")
#	message(FATAL_ERROR "No files generated")
#endif(
readVariable(MakeList SRCS LIBQUCS_SRC)
list(APPEND LIBQUCS_SRC ${generated_SRC})

#
# Template classes
#
readVariable(MakeList TEMPLATE_HDRS TEMPLATES)

#
# Include headers to be installed
#
readVariable(MakeList HDRS PUBLIC_HEADERS)
list(APPEND PUBLIC_HEADERS
        ${qucsator_BINARY_DIR}/config.h
	${qucsator_BINARY_DIR}/qucs_typedefs.h)

include(${qucsator_app_SOURCE_DIR}/cmake/generateGPerfAppHashCpp.cmake)

 #target <- source (includea) equation.cpp: gperfapphash.cpp

 #noinst_PROGRAMS = gperfappgen gperfappgen_SOURCES = gperfappgen.cpp

# for cleaning (autogenerated) set(gperf_FILES gperfapphash.cpp gperfapphash.gph
# gperfappgen.h)

## Qucs library dependencies
add_subdirectory(components)
add_subdirectory(components/digital)
add_subdirectory(components/devices)
add_subdirectory(components/microstrip)
if (USE_VERILOG)
	add_subdirectory(interface)
	add_subdirectory(components/verilog)
endif()
add_subdirectory(math)

# Qucsconv application
add_subdirectory(converter)

#
# Build libqucs as SHARED, dynamic library
#
# After: - http://stackoverflow.com/questions/11429055/cmake-how-create-a-
# single-shared-library-from-all-static-libraries-of-subprojec
#
add_library(
  libqucsator SHARED
  ${LIBQUCS_SRC}
  gperfapphash.cpp

  )
target_link_libraries(libqucsator PUBLIC
	coreMath
	coreComponents
	coreMicrostrip
	coreDevices
	coreDigital
	${CMAKE_DL_LIBS} # for dlerror(), dlopen() ...
)
if (USE_VERILOG)
	target_link_libraries(libqucsator PUBLIC coreInterface coreVerilog)
endif()

target_include_directories(libqucsator
	PUBLIC ${PROJECT_SOURCE_DIR}
	PRIVATE
	${qucsator_BINARY_DIR}	    # qucs_typedefs.h
	${qucsator_app_BINARY_DIR}  # generated sources by bison and flex are located here
	)

# rename the library to let it be libqucsator (not liblibqucsator).
# The target name must be unique and qucsator is already used for the application
set_target_properties(libqucsator PROPERTIES OUTPUT_NAME qucsator)

#
# Create target to handle gperfapp dependency
#
add_custom_target(equation DEPENDS ${qucsator_app_BINARY_DIR}/gperfapphash.cpp
	${PROJECT_SOURCE_DIR}/equation.cpp)
add_dependencies(libqucsator equation)

#
# Create qucsator application
#
add_executable(qucsator ucs.cpp)
target_include_directories(qucsator
	PRIVATE
	${qucsator_SOURCE_DIR}
	${qucsator_BINARY_DIR}
	)
## DL libs needed for opening a shared library
target_link_libraries(qucsator libqucsator ${CMAKE_DL_LIBS})

#
# Handle install
#
install(TARGETS qucsator DESTINATION bin)

# set Windows runtime location for libqucsator See:
# http://www.cmake.org/pipermail/cmake/2010-June/037461.html
install(
  TARGETS libqucsator
  RUNTIME DESTINATION bin COMPONENT runtime
  ARCHIVE DESTINATION lib COMPONENT devel
  LIBRARY DESTINATION lib COMPONENT library)

#install(FILES ${PUBLIC_HEADERS} DESTINATION include/qucsator)
